import 'dart:async';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:quotebot_vision/domain/entities/message.dart';
import 'package:quotebot_vision/domain/repositories/chat_repository.dart';
import 'chat_event.dart';
import 'chat_state.dart';

class ChatBloc extends Bloc<ChatEvent, ChatState> {
  final ChatRepository _chatRepository;
  StreamSubscription? _messagesSubscription;

  ChatBloc(this._chatRepository) : super(ChatInitial()) {
    on<LoadMessages>(_onLoadMessages);
    on<SendMessage>(_onSendMessage);
    on<UpdateMessages>(_onUpdateMessages);
  }

  Future<void> _onLoadMessages(
      LoadMessages event, Emitter<ChatState> emit) async {
    emit(ChatLoading());
    await _messagesSubscription?.cancel();
    _messagesSubscription = _chatRepository
        .getMessages(event.projectId)
        .listen((messages) => add(UpdateMessages(messages)));
  }

  void _onUpdateMessages(UpdateMessages event, Emitter<ChatState> emit) {
    emit(ChatLoaded(event.messages));
  }

  Future<void> _onSendMessage(
      SendMessage event, Emitter<ChatState> emit) async {
    try {
      final message = Message(
        id: '', // Generated by Firestore
        senderId: event.senderId,
        senderName: event.senderName,
        content: event.content,
        timestamp: DateTime.now(),
        type: event.type,
      );
      await _chatRepository.sendMessage(event.projectId, message);
    } catch (e) {
      // Typically we might want to show a snackbar or separate error state,
      // but without disrupting the message flow.
      // For now, we rely on the stream to update UI.
      // If error, maybe emit error? But that replaces the list.
      // Better to handle errors via status stream or similar.
      // Keeping simple for now.
      // print('Error sending message: $e');
    }
  }

  @override
  Future<void> close() {
    _messagesSubscription?.cancel();
    return super.close();
  }
}
